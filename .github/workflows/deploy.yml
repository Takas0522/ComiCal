# Complete Automated Deployment Workflow
# This workflow handles infrastructure, Functions, and Static Web Apps deployment
# Supports semantic versioning tags (v*.*.*) for production deployment
# Automatic dev deployment on push without tags

name: Complete Deployment

on:
  push:
    branches:
      - main
    tags:
      - 'v*.*.*'  # Semantic versioning tags trigger production deployment
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - dev
          - prod
      dry_run:
        description: 'Perform a what-if deployment (no actual changes)'
        required: false
        type: boolean
        default: false
      skip_infra:
        description: 'Skip infrastructure deployment'
        required: false
        type: boolean
        default: false
      skip_api_functions:
        description: 'Skip API Functions deployment'
        required: false
        type: boolean
        default: false
      skip_batch_functions:
        description: 'Skip Batch Functions deployment'
        required: false
        type: boolean
        default: false
      skip_database:
        description: 'Skip database initialization'
        required: false
        type: boolean
        default: false
      skip_frontend:
        description: 'Skip Static Web Apps deployment'
        required: false
        type: boolean
        default: false

permissions:
  id-token: write
  contents: read

env:
  AZURE_LOCATION: eastus2
  DOTNET_VERSION: '10'

jobs:
  # Determine environment based on semantic versioning tag
  determine-environment:
    name: Determine Deployment Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      version: ${{ steps.env.outputs.version }}
      is_semantic_version: ${{ steps.env.outputs.is_semantic_version }}
      deploy_infra: ${{ steps.env.outputs.deploy_infra }}
      deploy_api_functions: ${{ steps.env.outputs.deploy_api_functions }}
      deploy_batch_functions: ${{ steps.env.outputs.deploy_batch_functions }}
      deploy_database: ${{ steps.env.outputs.deploy_database }}
      deploy_frontend: ${{ steps.env.outputs.deploy_frontend }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Get full history for change detection

      - name: Detect changed files
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            infra:
              - 'infra/**'
            api:
              - 'src/ComiCal.Server/Comical.Api/**'
              - 'src/api/**'
            batch:
              - 'src/ComiCal.Server/ComiCal.Batch/**'
            database:
              - 'src/database/**'
            shared:
              - 'src/ComiCal.Server/ComiCal.Shared/**'
            frontend:
              - 'src/front/**'
      - name: Determine environment from tag or input
        id: env
        run: |
          # Determine environment
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            VERSION=""
            IS_SEMANTIC_VERSION="false"
          elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            ENVIRONMENT="prod"
            VERSION="${GITHUB_REF#refs/tags/}"
            IS_SEMANTIC_VERSION="true"
          else
            ENVIRONMENT="dev"
            VERSION=""
            IS_SEMANTIC_VERSION="false"
          fi
          
          # Validate semantic version format (v*.*.*) 
          if [[ "$IS_SEMANTIC_VERSION" == "true" ]]; then
            if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "âŒ Invalid semantic version format: $VERSION (expected v*.*.*)"
              exit 1
            fi
            echo "âœ… Valid semantic version detected: $VERSION"
          fi
          
          # Determine what to deploy
          DEPLOY_INFRA="true"
          DEPLOY_API_FUNCTIONS="true"
          DEPLOY_BATCH_FUNCTIONS="true"
          DEPLOY_DATABASE="true"
          DEPLOY_FRONTEND="true"
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual dispatch: use input parameters
            if [[ "${{ github.event.inputs.skip_infra }}" == "true" ]]; then
              DEPLOY_INFRA="false"
            fi
            if [[ "${{ github.event.inputs.skip_api_functions }}" == "true" ]]; then
              DEPLOY_API_FUNCTIONS="false"
            fi
            if [[ "${{ github.event.inputs.skip_batch_functions }}" == "true" ]]; then
              DEPLOY_BATCH_FUNCTIONS="false"
            fi
            if [[ "${{ github.event.inputs.skip_database }}" == "true" ]]; then
              DEPLOY_DATABASE="false"
            fi
            if [[ "${{ github.event.inputs.skip_frontend }}" == "true" ]]; then
              DEPLOY_FRONTEND="false"
            fi
          else
            # Automatic push: deploy based on changed files
            DEPLOY_INFRA="${{ steps.changes.outputs.infra }}"
            DEPLOY_DATABASE="${{ steps.changes.outputs.database }}"
            
            # Deploy API if API or shared components changed
            if [[ "${{ steps.changes.outputs.api }}" == "true" ]] || [[ "${{ steps.changes.outputs.shared }}" == "true" ]]; then
              DEPLOY_API_FUNCTIONS="true"
            else
              DEPLOY_API_FUNCTIONS="false"
            fi
            
            # Deploy Batch if Batch or shared components changed
            if [[ "${{ steps.changes.outputs.batch }}" == "true" ]] || [[ "${{ steps.changes.outputs.shared }}" == "true" ]]; then
              DEPLOY_BATCH_FUNCTIONS="true"
            else
              DEPLOY_BATCH_FUNCTIONS="false"
            fi
            
            # Deploy Frontend if frontend components changed
            DEPLOY_FRONTEND="${{ steps.changes.outputs.frontend }}"
            
            # For tagged releases, always deploy everything
            if [[ "$IS_SEMANTIC_VERSION" == "true" ]]; then
              DEPLOY_INFRA="true"
              DEPLOY_API_FUNCTIONS="true"
              DEPLOY_BATCH_FUNCTIONS="true"
              DEPLOY_DATABASE="true"
              DEPLOY_FRONTEND="true"
            fi
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "is_semantic_version=$IS_SEMANTIC_VERSION" >> $GITHUB_OUTPUT
          echo "deploy_infra=$DEPLOY_INFRA" >> $GITHUB_OUTPUT
          echo "deploy_api_functions=$DEPLOY_API_FUNCTIONS" >> $GITHUB_OUTPUT
          echo "deploy_batch_functions=$DEPLOY_BATCH_FUNCTIONS" >> $GITHUB_OUTPUT
          echo "deploy_database=$DEPLOY_DATABASE" >> $GITHUB_OUTPUT
          echo "deploy_frontend=$DEPLOY_FRONTEND" >> $GITHUB_OUTPUT
          
          echo "ðŸŽ¯ Target Environment: $ENVIRONMENT"
          echo "ðŸ“¦ Version: ${VERSION:-untagged}"
          echo "ðŸ—ï¸  Deploy Infrastructure: $DEPLOY_INFRA"
          echo "âš¡ Deploy API Functions: $DEPLOY_API_FUNCTIONS"
          echo "ðŸ”„ Deploy Batch Functions: $DEPLOY_BATCH_FUNCTIONS"
          echo "ðŸ—„ï¸  Deploy Database: $DEPLOY_DATABASE"
          echo "ðŸŒ Deploy Frontend: $DEPLOY_FRONTEND"
          
          if [[ "${{ github.event_name }}" != "workflow_dispatch" ]]; then
            echo "ðŸ“ Changed Components:"
            echo "  - Infrastructure: ${{ steps.changes.outputs.infra }}"
            echo "  - API: ${{ steps.changes.outputs.api }}"
            echo "  - Batch: ${{ steps.changes.outputs.batch }}"
            echo "  - Database: ${{ steps.changes.outputs.database }}"
            echo "  - Shared: ${{ steps.changes.outputs.shared }}"
            echo "  - Frontend: ${{ steps.changes.outputs.frontend }}"
          fi

  # Validate Bicep templates
  validate-bicep:
    name: Validate Bicep Templates
    runs-on: ubuntu-latest
    needs: determine-environment
    if: needs.determine-environment.outputs.deploy_infra == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Validate Bicep syntax
        run: |
          echo "ðŸ” Validating Bicep syntax..."
          az bicep build --file infra/main.bicep
          echo "âœ… Bicep syntax validation passed"

      - name: Run Bicep linter
        run: |
          echo "ðŸ” Running Bicep linter..."
          az bicep lint --file infra/main.bicep
          echo "âœ… Bicep linter passed"

  # Deploy infrastructure
  deploy-infrastructure:
    name: Deploy Infrastructure to ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [determine-environment, validate-bicep]
    if: needs.determine-environment.outputs.deploy_infra == 'true'
    environment:
      name: ${{ needs.determine-environment.outputs.environment }}
      url: https://portal.azure.com/#@/browse/resourcegroups
    outputs:
      resource_group: ${{ steps.deploy.outputs.resourceGroupName }}
      api_container_app_name: ${{ steps.deploy.outputs.apiContainerAppName }}
      batch_container_app_name: ${{ steps.deploy.outputs.batchContainerAppName }}
      postgres_server: ${{ steps.deploy.outputs.postgresServerName }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Build deployment parameters
        id: params
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"
          VERSION="${{ needs.determine-environment.outputs.version }}"
          
          # Base parameters
          PARAM_FILE="infra/parameters/${ENV}.bicepparam"
          BASE_PARAMS="postgresAdminPassword=${{ secrets.POSTGRES_ADMIN_PASSWORD }} rakutenApiKey=${{ secrets.RAKUTEN_APP_ID }}"
          
          # Add git tag if semantic version
          if [[ -n "$VERSION" ]]; then
            PARAMS="$PARAM_FILE gitTag=$VERSION $BASE_PARAMS"
          else
            PARAMS="$PARAM_FILE $BASE_PARAMS"
          fi
          
          # Add alert email addresses if configured
          if [[ -n "${{ secrets.ALERT_EMAIL_ADDRESSES }}" ]]; then
            PARAMS="$PARAMS alertEmailAddresses='${{ secrets.ALERT_EMAIL_ADDRESSES }}'"
          fi
          
          echo "parameters=$PARAMS" >> $GITHUB_OUTPUT

      - name: What-If Deployment (Preview Changes)
        if: github.event.inputs.dry_run == 'true'
        run: |
          echo "ðŸ” Running what-if deployment..."
          az deployment sub what-if \
            --name "comical-infra-${{ needs.determine-environment.outputs.environment }}-eu2-${{ github.run_number }}" \
            --location ${{ env.AZURE_LOCATION }} \
            --template-file infra/main.bicep \
            --parameters ${{ steps.params.outputs.parameters }}

      - name: Deploy Infrastructure
        id: deploy
        if: github.event.inputs.dry_run != 'true'
        run: |
          echo "ðŸš€ Deploying infrastructure..."
          az deployment sub create \
            --name "comical-infra-${{ needs.determine-environment.outputs.environment }}-eu2-${{ github.run_number }}" \
            --location ${{ env.AZURE_LOCATION }} \
            --template-file infra/main.bicep \
            --parameters ${{ steps.params.outputs.parameters }} \
            --query 'properties.outputs' \
            --output json > deployment_outputs.json
          
          # Extract outputs for other jobs
          RESOURCE_GROUP=$(jq -r '.resourceGroupName.value' deployment_outputs.json)
          API_CONTAINER_APP_NAME=$(jq -r '.apiContainerAppName.value' deployment_outputs.json)
          BATCH_CONTAINER_APP_NAME=$(jq -r '.batchContainerAppName.value' deployment_outputs.json)
          POSTGRES_SERVER=$(jq -r '.postgresServerName.value' deployment_outputs.json)
          APP_INSIGHTS_NAME=$(jq -r '.appInsightsName.value // "N/A"' deployment_outputs.json)
          APP_INSIGHTS_ID=$(jq -r '.appInsightsId.value // "N/A"' deployment_outputs.json)
          ALERTS_ENABLED=$(jq -r '.alertsEnabled.value // "false"' deployment_outputs.json)
          ACTION_GROUP_NAME=$(jq -r '.actionGroupName.value // "N/A"' deployment_outputs.json)
          
          echo "resourceGroupName=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "apiContainerAppName=$API_CONTAINER_APP_NAME" >> $GITHUB_OUTPUT
          echo "batchContainerAppName=$BATCH_CONTAINER_APP_NAME" >> $GITHUB_OUTPUT
          echo "postgresServerName=$POSTGRES_SERVER" >> $GITHUB_OUTPUT
          echo "appInsightsName=$APP_INSIGHTS_NAME" >> $GITHUB_OUTPUT
          echo "appInsightsId=$APP_INSIGHTS_ID" >> $GITHUB_OUTPUT
          echo "alertsEnabled=$ALERTS_ENABLED" >> $GITHUB_OUTPUT
          echo "actionGroupName=$ACTION_GROUP_NAME" >> $GITHUB_OUTPUT

      - name: Configure PostgreSQL Managed Identity
        if: github.event.inputs.dry_run != 'true'
        run: |
          echo "ðŸ” Configuring PostgreSQL Managed Identity..."
          
          POSTGRES_SERVER="${{ steps.deploy.outputs.postgresServerName }}"
          RESOURCE_GROUP="${{ steps.deploy.outputs.resourceGroupName }}"
          API_APP_NAME="${{ steps.deploy.outputs.apiFunctionAppName }}"
          BATCH_APP_NAME="${{ steps.deploy.outputs.batchFunctionAppName }}"
          
          # Note: Container Apps don't currently support PostgreSQL AAD authentication the same way as Function Apps
          # This is a placeholder for future implementation when needed
          echo "â„¹ï¸  PostgreSQL Managed Identity configuration for Container Apps is not yet implemented"
          echo "â„¹ï¸  Using connection string authentication for now"

      - name: Display deployment summary
        if: github.event.inputs.dry_run != 'true'
        run: |
          echo "## ðŸŽ‰ Infrastructure Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ needs.determine-environment.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ needs.determine-environment.outputs.version || 'untagged' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Resource Group**: ${{ steps.deploy.outputs.resourceGroupName }}" >> $GITHUB_STEP_SUMMARY
          echo "- **PostgreSQL Server**: ${{ steps.deploy.outputs.postgresServerName }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Application Insights**: ${{ steps.deploy.outputs.appInsightsName }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Alerts Enabled**: ${{ steps.deploy.outputs.alertsEnabled }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Monitoring" >> $GITHUB_STEP_SUMMARY
          echo "- Application Insights: [View in Portal](https://portal.azure.com/#@/resource${{ steps.deploy.outputs.appInsightsId }})" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ steps.deploy.outputs.alertsEnabled }}" == "true" ]]; then
            echo "- Action Group: ${{ steps.deploy.outputs.actionGroupName }}" >> $GITHUB_STEP_SUMMARY
          fi

  # Initialize database schema and seed data
  initialize-database:
    name: Initialize Database to ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-infrastructure]
    if: |
      always() &&
      !cancelled() &&
      needs.determine-environment.result == 'success' &&
      (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped') &&
      needs.determine-environment.outputs.deploy_database == 'true' &&
      github.event.inputs.dry_run != 'true'
    environment:
      name: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install PostgreSQL client
        run: |
          echo "ðŸ“¦ Installing PostgreSQL client..."
          sudo apt-get update
          sudo apt-get install -y postgresql-client
          echo "âœ… PostgreSQL client installed"

      - name: Build database connection string
        id: db_connection
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"
          
          # Use outputs from infrastructure deployment if available, otherwise construct from naming convention
          POSTGRES_SERVER="${{ needs.deploy-infrastructure.outputs.postgres_server }}"
          RESOURCE_GROUP="${{ needs.deploy-infrastructure.outputs.resource_group }}"
          
          # If outputs are empty (infrastructure was skipped), construct names from convention
          if [[ -z "$POSTGRES_SERVER" ]]; then
            echo "âš ï¸  Infrastructure outputs not available, constructing names from convention..."
            PROJECT_NAME="comical"
            if [[ "$ENV" == "dev" ]]; then
              ENV_SHORT="d"
            else
              ENV_SHORT="p"
            fi
            LOCATION_SHORT="eu2"
            
            POSTGRES_SERVER="psql-${PROJECT_NAME}-${ENV_SHORT}-${LOCATION_SHORT}"
            RESOURCE_GROUP="rg-${PROJECT_NAME}-${ENV_SHORT}-${LOCATION_SHORT}"
            
            # Verify the resources exist
            echo "ðŸ” Verifying PostgreSQL server exists..."
            if ! az postgres flexible-server show --resource-group "$RESOURCE_GROUP" --name "$POSTGRES_SERVER" &>/dev/null; then
              echo "âŒ PostgreSQL server not found: $POSTGRES_SERVER in $RESOURCE_GROUP"
              echo "Available PostgreSQL servers:"
              az postgres flexible-server list --resource-group "$RESOURCE_GROUP" --output table || echo "No servers found or resource group doesn't exist"
              exit 1
            fi
            echo "âœ… PostgreSQL server verified: $POSTGRES_SERVER"
          fi
          
          # Get PostgreSQL server details
          DB_HOST="${POSTGRES_SERVER}.postgres.database.azure.com"
          DB_NAME="comical"
          DB_USER="comical_admin"
          
          echo "postgres_server=$POSTGRES_SERVER" >> $GITHUB_OUTPUT
          echo "resource_group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "db_host=$DB_HOST" >> $GITHUB_OUTPUT
          echo "db_name=$DB_NAME" >> $GITHUB_OUTPUT
          echo "db_user=$DB_USER" >> $GITHUB_OUTPUT
          
          echo "ðŸ”— Database connection configured:"
          echo "  PostgreSQL Server: $POSTGRES_SERVER"
          echo "  Resource Group: $RESOURCE_GROUP"
          echo "  Host: $DB_HOST"
          echo "  Database: $DB_NAME"
          echo "  User: $DB_USER"

      - name: Add GitHub Runner IP to PostgreSQL firewall
        run: |
          echo "ðŸ”§ Adding GitHub Runner IP to PostgreSQL firewall..."
          # Get the public IP of the GitHub runner
          RUNNER_IP=$(curl -s https://checkip.amazonaws.com || curl -s https://ipv4.icanhazip.com)
          echo "Runner IP: $RUNNER_IP"
          
          RESOURCE_GROUP="${{ steps.db_connection.outputs.resource_group }}"
          POSTGRES_SERVER="${{ steps.db_connection.outputs.postgres_server }}"
          
          echo "Using Resource Group: $RESOURCE_GROUP"
          echo "Using PostgreSQL Server: $POSTGRES_SERVER"
          
          # Add firewall rule for the runner IP
          az postgres flexible-server firewall-rule create \
            --resource-group $RESOURCE_GROUP \
            --name $POSTGRES_SERVER \
            --rule-name "AllowGitHubRunner" \
            --start-ip-address $RUNNER_IP \
            --end-ip-address $RUNNER_IP
          
          echo "âœ… Firewall rule added for IP: $RUNNER_IP"

      - name: Test database connectivity
        env:
          PGPASSWORD: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
        run: |
          echo "ðŸ” Testing database connectivity..."
          pg_isready -h ${{ steps.db_connection.outputs.db_host }} -U ${{ steps.db_connection.outputs.db_user }}
          echo "âœ… Database server is ready"

      - name: Initialize database schema
        env:
          PGPASSWORD: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
          PGSSLMODE: require
        run: |
          echo "ðŸ—ï¸  Initializing database schema..."
          psql "sslmode=require host=${{ steps.db_connection.outputs.db_host }} user=${{ steps.db_connection.outputs.db_user }} dbname=${{ steps.db_connection.outputs.db_name }}" \
               -f src/database/init.sql \
               -v ON_ERROR_STOP=1
          echo "âœ… Database schema initialized successfully"

      - name: Display database initialization summary
        run: |
          echo "## ðŸ—„ï¸  Database Initialization Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ needs.determine-environment.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Database Host**: ${{ steps.db_connection.outputs.db_host }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Database Name**: ${{ steps.db_connection.outputs.db_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Schema Initialized**: âœ…" >> $GITHUB_STEP_SUMMARY

      - name: Remove GitHub Runner IP from PostgreSQL firewall
        if: always()  # Run even if previous steps failed
        run: |
          echo "ðŸ§¹ Removing GitHub Runner IP from PostgreSQL firewall..."
          
          RESOURCE_GROUP="${{ steps.db_connection.outputs.resource_group }}"
          POSTGRES_SERVER="${{ steps.db_connection.outputs.postgres_server }}"
          
          # Remove the temporary firewall rule
          az postgres flexible-server firewall-rule delete \
            --resource-group $RESOURCE_GROUP \
            --name $POSTGRES_SERVER \
            --rule-name "AllowGitHubRunner" \
            --yes || true  # Don't fail if rule doesn't exist
          
          echo "âœ… Firewall rule cleanup completed"

  # Build and deploy API Functions
  deploy-api-functions:
    name: Deploy API Container Apps to ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-infrastructure, initialize-database]
    if: |
      always() &&
      !cancelled() &&
      needs.determine-environment.result == 'success' &&
      (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped') &&
      (needs.initialize-database.result == 'success' || needs.initialize-database.result == 'skipped') &&
      needs.determine-environment.outputs.deploy_api_functions == 'true' &&
      github.event.inputs.dry_run != 'true'
    environment:
      name: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Container Apps API deployment placeholder
        run: |
          echo "ðŸš€ Container Apps API deployment..."
          echo "â„¹ï¸  API is deployed via Container Apps infrastructure"
          echo "â„¹ï¸  No additional deployment steps required for Container Apps"
          echo "âœ… Container Apps API deployment complete"
          
          # NOTE: If you need to add actual deployment steps in the future:
          # 1. Get resource names from outputs (if available) or construct from naming convention
          # 2. Example pattern used in initialize-database job:
          #    RESOURCE_NAME="${{ needs.deploy-infrastructure.outputs.resource_name }}"
          #    if [[ -z "$RESOURCE_NAME" ]]; then
          #      # Construct from naming convention
          #      ENV="${{ needs.determine-environment.outputs.environment }}"
          #      RESOURCE_NAME="ca-comical-${ENV:0:1}-eu2"  # Container App naming
          #    fi

  # Build and deploy Batch Functions
  deploy-batch-functions:
    name: Deploy Batch Container Apps to ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-infrastructure, initialize-database]
    if: |
      always() &&
      !cancelled() &&
      needs.determine-environment.result == 'success' &&
      (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped') &&
      (needs.initialize-database.result == 'success' || needs.initialize-database.result == 'skipped') &&
      needs.determine-environment.outputs.deploy_batch_functions == 'true' &&
      github.event.inputs.dry_run != 'true'
    environment:
      name: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Container Apps Batch deployment placeholder
        run: |
          echo "ðŸš€ Container Apps Batch deployment..."
          echo "â„¹ï¸  Batch is deployed via Container Apps infrastructure"
          echo "â„¹ï¸  No additional deployment steps required for Container Apps"
          echo "âœ… Container Apps Batch deployment complete"
          
          # NOTE: If you need to add actual deployment steps in the future:
          # 1. Get resource names from outputs (if available) or construct from naming convention
          # 2. Example pattern used in initialize-database job:
          #    RESOURCE_NAME="${{ needs.deploy-infrastructure.outputs.resource_name }}"
          #    if [[ -z "$RESOURCE_NAME" ]]; then
          #      # Construct from naming convention
          #      ENV="${{ needs.determine-environment.outputs.environment }}"
          #      RESOURCE_NAME="ca-comical-batch-${ENV:0:1}-eu2"  # Container App naming
          #    fi

  # Build and deploy Static Web Apps (Frontend)
  deploy-frontend:
    name: Deploy Static Web App to ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-infrastructure]
    if: |
      always() &&
      !cancelled() &&
      needs.determine-environment.result == 'success' &&
      (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped') &&
      needs.determine-environment.outputs.deploy_frontend == 'true' &&
      github.event.inputs.dry_run != 'true'
    environment:
      name: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: src/front/package-lock.json

      - name: Install dependencies
        run: |
          echo "ðŸ“¦ Installing frontend dependencies..."
          cd src/front
          npm install
          echo "âœ… Dependencies installed"

      - name: Build Angular app
        run: |
          echo "ðŸ”¨ Building Angular application..."
          cd src/front
          npm run build -- --configuration=${{ needs.determine-environment.outputs.environment }}
          echo "âœ… Build complete"
          echo "ðŸ“ Build output location: dist/front/browser"

      - name: Deploy to Azure Static Web Apps
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_AGREEABLE_STONE_05F92CB00 }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: "upload"
          app_location: "src/front/dist/front/browser"
          api_location: ""
          output_location: ""
          skip_app_build: true  # We already built the app

      - name: Display frontend deployment summary
        run: |
          echo "## ðŸŒ Frontend Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ needs.determine-environment.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Configuration**: ${{ needs.determine-environment.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Static Web App**: âœ… Deployed successfully" >> $GITHUB_STEP_SUMMARY

  # Notify deployment result
  notify-deployment:
    name: Notify Deployment Result
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-infrastructure, initialize-database, deploy-api-functions, deploy-batch-functions, deploy-frontend]
    if: always() && !cancelled() && needs.determine-environment.result == 'success'
    steps:
      - name: Determine deployment status
        id: status
        run: |
          INFRA_STATUS="${{ needs.deploy-infrastructure.result }}"
          DB_STATUS="${{ needs.initialize-database.result }}"
          API_STATUS="${{ needs.deploy-api-functions.result }}"
          BATCH_STATUS="${{ needs.deploy-batch-functions.result }}"
          FRONTEND_STATUS="${{ needs.deploy-frontend.result }}"
          
          if [[ "$INFRA_STATUS" == "success" ]] && ([[ "$DB_STATUS" == "success" ]] || [[ "$DB_STATUS" == "skipped" ]]) && ([[ "$API_STATUS" == "success" ]] || [[ "$API_STATUS" == "skipped" ]]) && ([[ "$BATCH_STATUS" == "success" ]] || [[ "$BATCH_STATUS" == "skipped" ]]) && ([[ "$FRONTEND_STATUS" == "success" ]] || [[ "$FRONTEND_STATUS" == "skipped" ]]); then
            STATUS="success"
            ICON="âœ…"
            MESSAGE="Deployment completed successfully"
          elif [[ "$INFRA_STATUS" == "failure" ]] || [[ "$DB_STATUS" == "failure" ]] || [[ "$API_STATUS" == "failure" ]] || [[ "$BATCH_STATUS" == "failure" ]] || [[ "$FRONTEND_STATUS" == "failure" ]]; then
            STATUS="failure"
            ICON="âŒ"
            MESSAGE="Deployment failed"
          else
            STATUS="cancelled"
            ICON="âš ï¸"
            MESSAGE="Deployment was cancelled"
          fi
          
          echo "status=$STATUS" >> $GITHUB_OUTPUT
          echo "icon=$ICON" >> $GITHUB_OUTPUT
          echo "message=$MESSAGE" >> $GITHUB_OUTPUT

      - name: Create deployment summary
        run: |
          echo "## ${{ steps.status.outputs.icon }} Deployment Status: ${{ steps.status.outputs.message }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ needs.determine-environment.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ needs.determine-environment.outputs.version || 'untagged' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Semantic Version**: ${{ needs.determine-environment.outputs.is_semantic_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Actor**: @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Component Status" >> $GITHUB_STEP_SUMMARY
          echo "- Infrastructure: ${{ needs.deploy-infrastructure.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Database: ${{ needs.initialize-database.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- API Functions: ${{ needs.deploy-api-functions.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Batch Functions: ${{ needs.deploy-batch-functions.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Frontend (Static Web App): ${{ needs.deploy-frontend.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ steps.status.outputs.status }}" == "failure" ]]; then
            echo "### ðŸ”„ Rollback Information" >> $GITHUB_STEP_SUMMARY
            echo "If you need to rollback this deployment, please refer to the [Rollback Guide](../docs/ROLLBACK_GUIDE.md)" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Post deployment notification
        if: always()
        run: |
          echo "${{ steps.status.outputs.icon }} ${{ steps.status.outputs.message }}"
          echo "Environment: ${{ needs.determine-environment.outputs.environment }}"
          echo "Version: ${{ needs.determine-environment.outputs.version || 'untagged' }}"
