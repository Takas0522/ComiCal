# Complete Automated Deployment Workflow
# This workflow handles infrastructure, Functions, and Static Web Apps deployment
# Supports semantic versioning tags (v*.*.*) for production deployment
# Automatic dev deployment on push without tags

name: Complete Deployment

on:
  push:
    branches:
      - main
    tags:
      - 'v*.*.*'  # Semantic versioning tags trigger production deployment
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - dev
          - prod
      dry_run:
        description: 'Perform a what-if deployment (no actual changes)'
        required: false
        type: boolean
        default: false
      skip_infra:
        description: 'Skip infrastructure deployment'
        required: false
        type: boolean
        default: false
      skip_api_functions:
        description: 'Skip API Functions deployment'
        required: false
        type: boolean
        default: false
      skip_batch_functions:
        description: 'Skip Batch Functions deployment'
        required: false
        type: boolean
        default: false
      skip_database:
        description: 'Skip database initialization'
        required: false
        type: boolean
        default: false

permissions:
  id-token: write
  contents: read

env:
  AZURE_LOCATION: eastus2
  DOTNET_VERSION: '10'

jobs:
  # Determine environment based on semantic versioning tag
  determine-environment:
    name: Determine Deployment Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      version: ${{ steps.env.outputs.version }}
      is_semantic_version: ${{ steps.env.outputs.is_semantic_version }}
      deploy_infra: ${{ steps.env.outputs.deploy_infra }}
      deploy_api_functions: ${{ steps.env.outputs.deploy_api_functions }}
      deploy_batch_functions: ${{ steps.env.outputs.deploy_batch_functions }}
      deploy_database: ${{ steps.env.outputs.deploy_database }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Get full history for change detection

      - name: Detect changed files
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            infra:
              - 'infra/**'
            api:
              - 'src/ComiCal.Server/Comical.Api/**'
              - 'src/api/**'
            batch:
              - 'src/ComiCal.Server/ComiCal.Batch/**'
            database:
              - 'src/database/**'
            shared:
              - 'src/ComiCal.Server/ComiCal.Shared/**'
      - name: Determine environment from tag or input
        id: env
        run: |
          # Determine environment
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            VERSION=""
            IS_SEMANTIC_VERSION="false"
          elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            ENVIRONMENT="prod"
            VERSION="${GITHUB_REF#refs/tags/}"
            IS_SEMANTIC_VERSION="true"
          else
            ENVIRONMENT="dev"
            VERSION=""
            IS_SEMANTIC_VERSION="false"
          fi
          
          # Validate semantic version format (v*.*.*) 
          if [[ "$IS_SEMANTIC_VERSION" == "true" ]]; then
            if [[ ! "$VERSION" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "âŒ Invalid semantic version format: $VERSION (expected v*.*.*)"
              exit 1
            fi
            echo "âœ… Valid semantic version detected: $VERSION"
          fi
          
          # Determine what to deploy
          DEPLOY_INFRA="true"
          DEPLOY_API_FUNCTIONS="true"
          DEPLOY_BATCH_FUNCTIONS="true"
          DEPLOY_DATABASE="true"
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual dispatch: use input parameters
            if [[ "${{ github.event.inputs.skip_infra }}" == "true" ]]; then
              DEPLOY_INFRA="false"
            fi
            if [[ "${{ github.event.inputs.skip_api_functions }}" == "true" ]]; then
              DEPLOY_API_FUNCTIONS="false"
            fi
            if [[ "${{ github.event.inputs.skip_batch_functions }}" == "true" ]]; then
              DEPLOY_BATCH_FUNCTIONS="false"
            fi
            if [[ "${{ github.event.inputs.skip_database }}" == "true" ]]; then
              DEPLOY_DATABASE="false"
            fi
          else
            # Automatic push: deploy based on changed files
            DEPLOY_INFRA="${{ steps.changes.outputs.infra }}"
            DEPLOY_DATABASE="${{ steps.changes.outputs.database }}"
            
            # Deploy API if API or shared components changed
            if [[ "${{ steps.changes.outputs.api }}" == "true" ]] || [[ "${{ steps.changes.outputs.shared }}" == "true" ]]; then
              DEPLOY_API_FUNCTIONS="true"
            else
              DEPLOY_API_FUNCTIONS="false"
            fi
            
            # Deploy Batch if Batch or shared components changed
            if [[ "${{ steps.changes.outputs.batch }}" == "true" ]] || [[ "${{ steps.changes.outputs.shared }}" == "true" ]]; then
              DEPLOY_BATCH_FUNCTIONS="true"
            else
              DEPLOY_BATCH_FUNCTIONS="false"
            fi
            
            # For tagged releases, always deploy everything
            if [[ "$IS_SEMANTIC_VERSION" == "true" ]]; then
              DEPLOY_INFRA="true"
              DEPLOY_API_FUNCTIONS="true"
              DEPLOY_BATCH_FUNCTIONS="true"
              DEPLOY_DATABASE="true"
            fi
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "is_semantic_version=$IS_SEMANTIC_VERSION" >> $GITHUB_OUTPUT
          echo "deploy_infra=$DEPLOY_INFRA" >> $GITHUB_OUTPUT
          echo "deploy_api_functions=$DEPLOY_API_FUNCTIONS" >> $GITHUB_OUTPUT
          echo "deploy_batch_functions=$DEPLOY_BATCH_FUNCTIONS" >> $GITHUB_OUTPUT
          echo "deploy_database=$DEPLOY_DATABASE" >> $GITHUB_OUTPUT
          
          echo "ðŸŽ¯ Target Environment: $ENVIRONMENT"
          echo "ðŸ“¦ Version: ${VERSION:-untagged}"
          echo "ðŸ—ï¸  Deploy Infrastructure: $DEPLOY_INFRA"
          echo "âš¡ Deploy API Functions: $DEPLOY_API_FUNCTIONS"
          echo "ðŸ”„ Deploy Batch Functions: $DEPLOY_BATCH_FUNCTIONS"
          echo "ðŸ—„ï¸  Deploy Database: $DEPLOY_DATABASE"
          
          if [[ "${{ github.event_name }}" != "workflow_dispatch" ]]; then
            echo "ðŸ“ Changed Components:"
            echo "  - Infrastructure: ${{ steps.changes.outputs.infra }}"
            echo "  - API: ${{ steps.changes.outputs.api }}"
            echo "  - Batch: ${{ steps.changes.outputs.batch }}"
            echo "  - Database: ${{ steps.changes.outputs.database }}"
            echo "  - Shared: ${{ steps.changes.outputs.shared }}"
          fi

  # Validate Bicep templates
  validate-bicep:
    name: Validate Bicep Templates
    runs-on: ubuntu-latest
    needs: determine-environment
    if: needs.determine-environment.outputs.deploy_infra == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Validate Bicep syntax
        run: |
          echo "ðŸ” Validating Bicep syntax..."
          az bicep build --file infra/main.bicep
          echo "âœ… Bicep syntax validation passed"

      - name: Run Bicep linter
        run: |
          echo "ðŸ” Running Bicep linter..."
          az bicep lint --file infra/main.bicep
          echo "âœ… Bicep linter passed"

  # Deploy infrastructure
  deploy-infrastructure:
    name: Deploy Infrastructure to ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [determine-environment, validate-bicep]
    if: needs.determine-environment.outputs.deploy_infra == 'true'
    environment:
      name: ${{ needs.determine-environment.outputs.environment }}
      url: https://portal.azure.com/#@/browse/resourcegroups
    outputs:
      resource_group: ${{ steps.deploy.outputs.resourceGroupName }}
      api_function_name: ${{ steps.deploy.outputs.apiFunctionAppName }}
      batch_function_name: ${{ steps.deploy.outputs.batchFunctionAppName }}
      postgres_server: ${{ steps.deploy.outputs.postgresServerName }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Build deployment parameters
        id: params
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"
          VERSION="${{ needs.determine-environment.outputs.version }}"
          
          # Base parameters
          PARAM_FILE="infra/parameters/${ENV}.bicepparam"
          BASE_PARAMS="postgresAdminPassword=${{ secrets.POSTGRES_ADMIN_PASSWORD }} rakutenApiKey=${{ secrets.RAKUTEN_APP_ID }}"
          
          # Add git tag if semantic version
          if [[ -n "$VERSION" ]]; then
            PARAMS="$PARAM_FILE gitTag=$VERSION $BASE_PARAMS"
          else
            PARAMS="$PARAM_FILE $BASE_PARAMS"
          fi
          
          # Add alert email addresses if configured
          if [[ -n "${{ secrets.ALERT_EMAIL_ADDRESSES }}" ]]; then
            PARAMS="$PARAMS alertEmailAddresses='${{ secrets.ALERT_EMAIL_ADDRESSES }}'"
          fi
          
          echo "parameters=$PARAMS" >> $GITHUB_OUTPUT

      - name: What-If Deployment (Preview Changes)
        if: github.event.inputs.dry_run == 'true'
        run: |
          echo "ðŸ” Running what-if deployment..."
          az deployment sub what-if \
            --name "comical-infra-${{ needs.determine-environment.outputs.environment }}-eu2-${{ github.run_number }}" \
            --location ${{ env.AZURE_LOCATION }} \
            --template-file infra/main.bicep \
            --parameters ${{ steps.params.outputs.parameters }}

      - name: Deploy Infrastructure
        id: deploy
        if: github.event.inputs.dry_run != 'true'
        run: |
          echo "ðŸš€ Deploying infrastructure..."
          az deployment sub create \
            --name "comical-infra-${{ needs.determine-environment.outputs.environment }}-eu2-${{ github.run_number }}" \
            --location ${{ env.AZURE_LOCATION }} \
            --template-file infra/main.bicep \
            --parameters ${{ steps.params.outputs.parameters }} \
            --query 'properties.outputs' \
            --output json > deployment_outputs.json
          
          # Extract outputs for other jobs
          RESOURCE_GROUP=$(jq -r '.resourceGroupName.value' deployment_outputs.json)
          API_FUNCTION_NAME=$(jq -r '.apiFunctionAppName.value' deployment_outputs.json)
          BATCH_FUNCTION_NAME=$(jq -r '.batchFunctionAppName.value' deployment_outputs.json)
          POSTGRES_SERVER=$(jq -r '.postgresServerName.value' deployment_outputs.json)
          APP_INSIGHTS_NAME=$(jq -r '.appInsightsName.value // "N/A"' deployment_outputs.json)
          APP_INSIGHTS_ID=$(jq -r '.appInsightsId.value // "N/A"' deployment_outputs.json)
          ALERTS_ENABLED=$(jq -r '.alertsEnabled.value // "false"' deployment_outputs.json)
          ACTION_GROUP_NAME=$(jq -r '.actionGroupName.value // "N/A"' deployment_outputs.json)
          
          echo "resourceGroupName=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "apiFunctionAppName=$API_FUNCTION_NAME" >> $GITHUB_OUTPUT
          echo "batchFunctionAppName=$BATCH_FUNCTION_NAME" >> $GITHUB_OUTPUT
          echo "postgresServerName=$POSTGRES_SERVER" >> $GITHUB_OUTPUT
          echo "appInsightsName=$APP_INSIGHTS_NAME" >> $GITHUB_OUTPUT
          echo "appInsightsId=$APP_INSIGHTS_ID" >> $GITHUB_OUTPUT
          echo "alertsEnabled=$ALERTS_ENABLED" >> $GITHUB_OUTPUT
          echo "actionGroupName=$ACTION_GROUP_NAME" >> $GITHUB_OUTPUT

      - name: Configure PostgreSQL Managed Identity
        if: github.event.inputs.dry_run != 'true'
        run: |
          echo "ðŸ” Configuring PostgreSQL Managed Identity..."
          
          POSTGRES_SERVER="${{ steps.deploy.outputs.postgresServerName }}"
          RESOURCE_GROUP="${{ steps.deploy.outputs.resourceGroupName }}"
          API_APP_NAME="${{ steps.deploy.outputs.apiFunctionAppName }}"
          BATCH_APP_NAME="${{ steps.deploy.outputs.batchFunctionAppName }}"
          
          # Note: Container Apps don't currently support PostgreSQL AAD authentication the same way as Function Apps
          # This is a placeholder for future implementation when needed
          echo "â„¹ï¸  PostgreSQL Managed Identity configuration for Container Apps is not yet implemented"
          echo "â„¹ï¸  Using connection string authentication for now"

      - name: Display deployment summary
        if: github.event.inputs.dry_run != 'true'
        run: |
          echo "## ðŸŽ‰ Infrastructure Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ needs.determine-environment.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ needs.determine-environment.outputs.version || 'untagged' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Resource Group**: ${{ steps.deploy.outputs.resourceGroupName }}" >> $GITHUB_STEP_SUMMARY
          echo "- **PostgreSQL Server**: ${{ steps.deploy.outputs.postgresServerName }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Application Insights**: ${{ steps.deploy.outputs.appInsightsName }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Alerts Enabled**: ${{ steps.deploy.outputs.alertsEnabled }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Monitoring" >> $GITHUB_STEP_SUMMARY
          echo "- Application Insights: [View in Portal](https://portal.azure.com/#@/resource${{ steps.deploy.outputs.appInsightsId }})" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ steps.deploy.outputs.alertsEnabled }}" == "true" ]]; then
            echo "- Action Group: ${{ steps.deploy.outputs.actionGroupName }}" >> $GITHUB_STEP_SUMMARY
          fi

  # Initialize database schema and seed data
  initialize-database:
    name: Initialize Database to ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-infrastructure]
    if: |
      needs.determine-environment.outputs.deploy_database == 'true' &&
      github.event.inputs.dry_run != 'true'
    environment:
      name: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install PostgreSQL client
        run: |
          echo "ðŸ“¦ Installing PostgreSQL client..."
          sudo apt-get update
          sudo apt-get install -y postgresql-client
          echo "âœ… PostgreSQL client installed"

      - name: Build database connection string
        id: db_connection
        run: |
          POSTGRES_SERVER="${{ needs.deploy-infrastructure.outputs.postgres_server }}"
          DB_NAME="comical"
          DB_USER="comical_admin"
          DB_HOST="${POSTGRES_SERVER}.postgres.database.azure.com"
          
          echo "db_host=$DB_HOST" >> $GITHUB_OUTPUT
          echo "db_name=$DB_NAME" >> $GITHUB_OUTPUT
          echo "db_user=$DB_USER" >> $GITHUB_OUTPUT
          
          echo "ðŸ”— Database connection configured:"
          echo "  Host: $DB_HOST"
          echo "  Database: $DB_NAME"
          echo "  User: $DB_USER"

      - name: Test database connectivity
        env:
          PGPASSWORD: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
        run: |
          echo "ðŸ” Testing database connectivity..."
          pg_isready -h ${{ steps.db_connection.outputs.db_host }} -U ${{ steps.db_connection.outputs.db_user }}
          echo "âœ… Database server is ready"

      - name: Initialize database schema
        env:
          PGPASSWORD: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
        run: |
          echo "ðŸ—ï¸  Initializing database schema..."
          psql -h ${{ steps.db_connection.outputs.db_host }} \
               -U ${{ steps.db_connection.outputs.db_user }} \
               -d ${{ steps.db_connection.outputs.db_name }} \
               -f src/database/init.sql \
               -v ON_ERROR_STOP=1
          echo "âœ… Database schema initialized successfully"

      - name: Seed database with initial data
        env:
          PGPASSWORD: ${{ secrets.POSTGRES_ADMIN_PASSWORD }}
        run: |
          echo "ðŸŒ± Seeding database with initial data..."
          # Only seed data in dev environment to avoid overwriting production data
          if [[ "${{ needs.determine-environment.outputs.environment }}" == "dev" ]]; then
            psql -h ${{ steps.db_connection.outputs.db_host }} \
                 -U ${{ steps.db_connection.outputs.db_user }} \
                 -d ${{ steps.db_connection.outputs.db_name }} \
                 -f src/database/seed.sql \
                 -v ON_ERROR_STOP=1
            echo "âœ… Sample data seeded successfully (dev environment)"
          else
            echo "â„¹ï¸  Skipping data seeding in production environment"
          fi

      - name: Display database initialization summary
        run: |
          echo "## ðŸ—„ï¸  Database Initialization Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ needs.determine-environment.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Database Host**: ${{ steps.db_connection.outputs.db_host }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Database Name**: ${{ steps.db_connection.outputs.db_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Schema Initialized**: âœ…" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ needs.determine-environment.outputs.environment }}" == "dev" ]]; then
            echo "- **Sample Data Seeded**: âœ…" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Sample Data Seeded**: âš ï¸ Skipped (production)" >> $GITHUB_STEP_SUMMARY
          fi

  # Build and deploy API Functions
  deploy-api-functions:
    name: Deploy API Functions to ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-infrastructure, initialize-database]
    if: |
      needs.determine-environment.outputs.deploy_api_functions == 'true' &&
      github.event.inputs.dry_run != 'true'
    environment:
      name: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET ${{ env.DOTNET_VERSION }}
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Build API Functions
        run: |
          echo "ðŸ”¨ Building API Functions..."
          cd src/ComiCal.Server/Comical.Api
          dotnet build --configuration Release --output ./output
          echo "âœ… Build complete"

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy to Container App
        run: |
          echo "ðŸš€ Deploying API Functions to Container App..."
          APP_NAME="${{ needs.deploy-infrastructure.outputs.api_function_name }}"
          RESOURCE_GROUP="${{ needs.deploy-infrastructure.outputs.resource_group }}"
          
          # Note: Container Apps deployment from Function code requires containerization
          # This is a placeholder - actual implementation depends on your container strategy
          echo "â„¹ï¸  Container Apps deployment from Functions code is not yet fully implemented"
          echo "â„¹ï¸  Please use container image deployment or migrate to Function Apps"
          echo "âœ… Deployment configuration prepared for: $APP_NAME"

  # Build and deploy Batch Functions
  deploy-batch-functions:
    name: Deploy Batch Functions to ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-infrastructure, initialize-database]
    if: |
      needs.determine-environment.outputs.deploy_batch_functions == 'true' &&
      github.event.inputs.dry_run != 'true'
    environment:
      name: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET ${{ env.DOTNET_VERSION }}
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Build Batch Functions
        run: |
          echo "ðŸ”¨ Building Batch Functions..."
          cd src/ComiCal.Server/ComiCal.Batch
          dotnet build --configuration Release --output ./output
          echo "âœ… Build complete"

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Deploy to Container App
        run: |
          echo "ðŸš€ Deploying Batch Functions to Container App..."
          APP_NAME="${{ needs.deploy-infrastructure.outputs.batch_function_name }}"
          RESOURCE_GROUP="${{ needs.deploy-infrastructure.outputs.resource_group }}"
          
          # Note: Container Apps deployment from Function code requires containerization
          # This is a placeholder - actual implementation depends on your container strategy
          echo "â„¹ï¸  Container Apps deployment from Functions code is not yet fully implemented"
          echo "â„¹ï¸  Please use container image deployment or migrate to Function Apps"
          echo "âœ… Deployment configuration prepared for: $APP_NAME"

  # Notify deployment result
  notify-deployment:
    name: Notify Deployment Result
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-infrastructure, initialize-database, deploy-api-functions, deploy-batch-functions]
    if: always() && needs.determine-environment.outputs.deploy_infra == 'true'
    steps:
      - name: Determine deployment status
        id: status
        run: |
          INFRA_STATUS="${{ needs.deploy-infrastructure.result }}"
          DB_STATUS="${{ needs.initialize-database.result }}"
          API_STATUS="${{ needs.deploy-api-functions.result }}"
          BATCH_STATUS="${{ needs.deploy-batch-functions.result }}"
          
          if [[ "$INFRA_STATUS" == "success" ]] && ([[ "$DB_STATUS" == "success" ]] || [[ "$DB_STATUS" == "skipped" ]]) && ([[ "$API_STATUS" == "success" ]] || [[ "$API_STATUS" == "skipped" ]]) && ([[ "$BATCH_STATUS" == "success" ]] || [[ "$BATCH_STATUS" == "skipped" ]]); then
            STATUS="success"
            ICON="âœ…"
            MESSAGE="Deployment completed successfully"
          elif [[ "$INFRA_STATUS" == "failure" ]] || [[ "$DB_STATUS" == "failure" ]] || [[ "$API_STATUS" == "failure" ]] || [[ "$BATCH_STATUS" == "failure" ]]; then
            STATUS="failure"
            ICON="âŒ"
            MESSAGE="Deployment failed"
          else
            STATUS="cancelled"
            ICON="âš ï¸"
            MESSAGE="Deployment was cancelled"
          fi
          
          echo "status=$STATUS" >> $GITHUB_OUTPUT
          echo "icon=$ICON" >> $GITHUB_OUTPUT
          echo "message=$MESSAGE" >> $GITHUB_OUTPUT

      - name: Create deployment summary
        run: |
          echo "## ${{ steps.status.outputs.icon }} Deployment Status: ${{ steps.status.outputs.message }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ needs.determine-environment.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ needs.determine-environment.outputs.version || 'untagged' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Semantic Version**: ${{ needs.determine-environment.outputs.is_semantic_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Actor**: @${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Component Status" >> $GITHUB_STEP_SUMMARY
          echo "- Infrastructure: ${{ needs.deploy-infrastructure.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Database: ${{ needs.initialize-database.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- API Functions: ${{ needs.deploy-api-functions.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Batch Functions: ${{ needs.deploy-batch-functions.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ steps.status.outputs.status }}" == "failure" ]]; then
            echo "### ðŸ”„ Rollback Information" >> $GITHUB_STEP_SUMMARY
            echo "If you need to rollback this deployment, please refer to the [Rollback Guide](../docs/ROLLBACK_GUIDE.md)" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Post deployment notification
        if: always()
        run: |
          echo "${{ steps.status.outputs.icon }} ${{ steps.status.outputs.message }}"
          echo "Environment: ${{ needs.determine-environment.outputs.environment }}"
          echo "Version: ${{ needs.determine-environment.outputs.version || 'untagged' }}"
